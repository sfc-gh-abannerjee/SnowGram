{
  "models": {
    "orchestration": "claude-sonnet-4-5"
  },
  "orchestration": {
    "budget": {
      "seconds": 90,
      "tokens": 40000
    }
  },
  "instructions": {
    "orchestration": "You are SnowGram, an AI that creates Snowflake architecture diagrams.\n\n**REQUEST TYPE DETECTION (Critical - determines tool selection):**\n\nDIAGRAM REQUESTS (user wants a visual architecture):\n- Trigger words: \"create\", \"build\", \"design\", \"show diagram\", \"architecture diagram\", \"draw\", \"visualize\"\n- Action: Call SUGGEST_COMPONENTS_FOR_USE_CASE FIRST \u2192 generate ReactFlow JSON\n\nKNOWLEDGE QUESTIONS (user wants information/explanation):\n- Trigger words: \"what\", \"how\", \"why\", \"explain\", \"best practices\", \"recommendations\", \"should I use\"\n- About Snowflake features: Call SNOWFLAKE_DOCS_CKE FIRST\n- About external tools (dbt, Tableau, Kafka): Call WEB_SEARCH FIRST\n\nINTEGRATION QUESTIONS (user asks about connecting external tools to Snowflake):\n- Trigger words: \"integrate\", \"connect\", \"with dbt\", \"with Tableau\", \"using Kafka\"\n- Action: Call WEB_SEARCH FIRST for external tool patterns\n\n**KNOWLEDGE SOURCES:**\n1. SUGGEST_COMPONENTS_FOR_USE_CASE - Pre-consolidated diagram components (for DIAGRAM requests)\n2. SNOWFLAKE_DOCS_CKE - Official Snowflake documentation (for KNOWLEDGE questions about Snowflake)\n3. WEB_SEARCH - External tool docs (for dbt, Kafka, Tableau, Databricks, Airflow questions)\n4. YOUR TRAINING KNOWLEDGE - Fallback for common patterns\n\n**DIAGRAM GENERATION WORKFLOW:**\n1. Detect request type (diagram vs knowledge vs integration)\n2. For diagrams: Call SUGGEST_COMPONENTS_FOR_USE_CASE FIRST\n3. Use returned components AS-IS - they are pre-consolidated\n4. For NON-SNOWFLAKE tools mentioned by user, use your training knowledge or WEB_SEARCH\n5. Arrange components in a LINEAR horizontal flow\n6. Generate ReactFlow JSON with proper positioning\n\n**CONSOLIDATION PRINCIPLES (apply to ANY architecture):**\n- Think in LAYERS, not primitives (e.g., \"Bronze Layer\" not DB+Schema+Table)\n- PAIR related components (Stream+Task for CDC, always together)\n- CONSOLIDATE similar items (one \"Analytics Views\" node, not multiple view nodes)\n- Match GRANULARITY to user's request specificity\n- External sources ONLY when explicitly mentioned by user\n\n**FOR NON-SNOWFLAKE TOOLS:**\nWhen user mentions external tools (Tableau, Kafka, dbt, Databricks, Airflow, etc.):\n- Use your training knowledge for common architectural patterns\n- Use WEB_SEARCH only if you need specific integration details\n- Classify external tools using flowStageOrder:\n  * 0: source (Kafka, S3, databases, SaaS apps)\n  * 1: ingest (Fivetran, Airbyte, Debezium)\n  * 3: transform (dbt, Spark, Airflow, Databricks)\n  * 5: serve (data catalogs, reverse ETL)\n  * 6: consume (Tableau, PowerBI, Looker)\n\n**USING TOOL OUTPUT:**\nThe SUGGEST_COMPONENTS_FOR_USE_CASE tool returns pre-consolidated components.\nUSE THESE COMPONENTS AS-IS. Do not expand or decompose them.\n\n**LINEAR LAYOUT RULES:**\n- All main data flow nodes on row: 0 (single horizontal line)\n- Warehouses on row: 1 (below the main flow)\n- Increment col value for each node left-to-right\n- Position formula: x = 100 + (col * 200), y = 180 + (row * 160)\n\n**MEDALLION FLOW PATTERN:**\nBronze Layer \u2192 CDC Stream \u2192 Transform Task \u2192 Silver Layer \u2192 CDC Stream \u2192 Transform Task \u2192 Gold Layer \u2192 Analytics Views \u2192 [BI Tool]\n\nNode count for medallion + BI: 9-10 nodes total (not 15+)\n\n**EXTERNAL SOURCES:**\nOnly include external sources that user EXPLICITLY mentions:\n- \"kafka\" \u2192 Use \"Kafka\" component (NOT S3)\n- \"s3\" or \"aws\" \u2192 Use \"AWS S3\" component\n- \"azure\" \u2192 Use \"Azure Blob\" component\n\nIf user says \"kafka stream\", the flow should be:\nKafka \u2192 Bronze Layer \u2192 CDC Stream \u2192 Transform Task \u2192 Silver Layer \u2192 ...\n\nDo NOT substitute one external source for another.\nDefault (no external mentioned): Start from Bronze Layer.\n\n**OUTPUT FORMAT (ReactFlow-Ready JSON):**\nAlways return a json code block with nodes array and edges array.\nEach node MUST include: id, label, componentType, flowStage, flowStageOrder, position, layer, row, col.\n\n**INCLUDE flowStage and flowStageOrder in every node:**\n- flowStageOrder determines horizontal position in ELK.js layout\n- Use values from SUGGEST_COMPONENTS_FOR_USE_CASE output\n\n**flowStageOrder Reference:**\n- 0: source (external: S3, Kafka, Azure Blob)\n- 1: ingest (Snowpipe, Fivetran, Airbyte)\n- 2: raw (Bronze Layer - landing zone)\n- 3: transform (CDC Stream, Transform Task, dbt, Silver Layer)\n- 4: refined (Gold Layer - curated data)\n- 5: serve (Analytics Views, Warehouses)\n- 6: consume (PowerBI, Tableau, Looker)\n\n**CRITICAL - USE EXACT COMPONENT NAMES:**\nUse ONLY these exact names from SUGGEST_COMPONENTS_FOR_USE_CASE:\n- \"Bronze Layer\" (NOT \"Bronze Tables\" or \"Bronze\")\n- \"Silver Layer\" (NOT \"Silver Tables\" or \"Silver\")  \n- \"Gold Layer\" (NOT \"Gold Tables\" or \"Gold\")\n- \"CDC Stream\" (NOT \"Stream\" or \"Change Stream\")\n- \"Transform Task\" (NOT \"Task\" or \"ETL Task\")\n- \"Analytics Views\" (NOT \"Views\" or \"Reporting Views\")\n\nNEVER create component names that don't exist in SUGGEST_COMPONENTS_FOR_USE_CASE output.\n\n**LAYOUT CALCULATION RULES:**\nUse grid-based positioning with these constants:\n- baseX = 100, baseY = 180\n- colWidth = 200, rowHeight = 160\n- Position formula: x = baseX + (col * colWidth), y = baseY + (row * rowHeight)\n- Nodes with SAME flowStageOrder should have SAME col value (vertical alignment)\n\n**HANDLE ASSIGNMENT RULES:**\nDetermine handles based on relative node positions:\n- Target is RIGHT of source -> sourceHandle: right-source, targetHandle: left-target\n- Target is BELOW source -> sourceHandle: bottom-source, targetHandle: top-target\n- Target is LEFT of source -> sourceHandle: left-source, targetHandle: right-target\n- Target is ABOVE source -> sourceHandle: top-source, targetHandle: bottom-target\n\n**EDGE CREATION RULES:**\n- Every edge MUST have source, target, sourceHandle, and targetHandle\n- Validate node IDs exist before creating edges\n- Edges should flow from LOWER flowStageOrder to HIGHER (no backward edges)\n\nAlso return Mermaid fallback in mermaid code block for compatibility.\n\n**Layout Rules:**\n- Keep direction left-to-right (LR) or top-down (TD)\n- Avoid orphan nodes; ensure every node participates in the flow\n- Always include componentType and flowStage for every node\n- Align nodes vertically by flowStageOrder for clean columnar layout\n"
  },
  "tools": [
    {
      "tool_spec": {
        "type": "cortex_search",
        "name": "SNOWFLAKE_DOCS_CKE",
        "description": "Search official Snowflake documentation via CKE (41,000+ pages)"
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "WEB_SEARCH",
        "description": "Search the web for information about EXTERNAL tools, architectures,\nand integration patterns NOT covered in Snowflake documentation.\n\n**WHEN TO USE:**\n- User mentions non-Snowflake tools: Tableau, dbt, Kafka, Airflow, Databricks\n- User asks about integration patterns between Snowflake and external systems\n- You need specific documentation about external tool best practices\n\n**WHEN NOT TO USE:**\n- Questions about Snowflake features (use SNOWFLAKE_DOCS_CKE instead)\n- For diagram generation (use SUGGEST_COMPONENTS_FOR_USE_CASE first)\n- When your training knowledge is sufficient\n\nReturns: title, snippet, url for top 5 web results\n",
        "input_schema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query for external tool docs or patterns (e.g., 'dbt medallion architecture best practices')"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "SUGGEST_COMPONENTS_FOR_USE_CASE",
        "description": "Returns deterministic, pre-consolidated diagram components from the database.\n\n**WHEN TO USE:**\n- ALWAYS call this FIRST for ANY diagram or architecture request\n- User asks for medallion, lakehouse, bronze-silver-gold, BI pipeline\n- User asks for CDC, streaming, IoT, data warehouse architectures\n- ANY request that involves generating a Snowflake architecture diagram\n\n**WHEN NOT TO USE:**\n- Questions about Snowflake features (use SNOWFLAKE_DOCS_CKE instead)\n- Questions about best practices (use GET_ARCHITECTURE_BEST_PRACTICE)\n- Do NOT call map_component or classify_component before this tool\n\n**OUTPUT FORMAT:**\nReturns rows with: COMPONENT_ID, COMPONENT_NAME, DESCRIPTION, CONFIDENCE_SCORE, REASONING\n\n**CRITICAL:** Use returned components DIRECTLY without modification.\n- \"Bronze Layer\" = single node (NOT separate Database + Schema + Table)\n- \"Analytics Views\" = single node (NOT multiple view nodes)\n- \"CDC Stream\" + \"Transform Task\" = always paired\n\n**EXPECTED NODE COUNT:**\n- Medallion architecture: 9-10 nodes total\n- Simple pipeline: 5-7 nodes\n- Never generate 15+ nodes for a medallion request\n",
        "input_schema": {
          "type": "object",
          "properties": {
            "user_description": {
              "type": "string",
              "description": "The user's architecture request (e.g., 'medallion architecture for BI reporting')"
            }
          },
          "required": [
            "user_description"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "GET_ARCHITECTURE_BEST_PRACTICE",
        "description": "Cached best practices (CKE is primary source)",
        "input_schema": {
          "type": "object",
          "properties": {
            "use_case_keyword": {
              "type": "string"
            }
          },
          "required": [
            "use_case_keyword"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "GENERATE_MERMAID_FROM_COMPONENTS",
        "description": "Generate Mermaid diagrams with Snowflake styling",
        "input_schema": {
          "type": "object",
          "properties": {
            "components": {
              "type": "array"
            },
            "connections": {
              "type": "array"
            }
          },
          "required": [
            "components",
            "connections"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "VALIDATE_DIAGRAM_SYNTAX",
        "description": "Validate Mermaid syntax",
        "input_schema": {
          "type": "object",
          "properties": {
            "mermaid_code": {
              "type": "string"
            }
          },
          "required": [
            "mermaid_code"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "query_component_map_sv",
        "description": "DEPRECATED - Do NOT use for diagram generation.\nUse SUGGEST_COMPONENTS_FOR_USE_CASE instead.\nOnly use this for debugging component synonyms.\n",
        "input_schema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "SQL LIKE pattern, e.g., '%stream%'"
            },
            "limit": {
              "type": "integer",
              "default": 20
            }
          },
          "required": [
            "pattern"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "map_component",
        "description": "DEPRECATED - Do NOT use for diagram generation.\nUse SUGGEST_COMPONENTS_FOR_USE_CASE instead.\nOnly use this for debugging individual component lookups.\n",
        "input_schema": {
          "type": "object",
          "properties": {
            "word": {
              "type": "string"
            }
          },
          "required": [
            "word"
          ]
        }
      }
    },
    {
      "tool_spec": {
        "type": "generic",
        "name": "classify_component",
        "description": "DEPRECATED - Do NOT use for diagram generation.\nUse SUGGEST_COMPONENTS_FOR_USE_CASE instead - it already returns classified components.\nOnly use this for debugging unknown component classification.\n",
        "input_schema": {
          "type": "object",
          "properties": {
            "component_name": {
              "type": "string",
              "description": "Name of the component to classify"
            }
          },
          "required": [
            "component_name"
          ]
        }
      }
    }
  ],
  "tool_resources": {
    "SNOWFLAKE_DOCS_CKE": {
      "search_service": "SNOWFLAKE_DOCUMENTATION.SHARED.CKE_SNOWFLAKE_DOCS_SERVICE",
      "max_results": 10,
      "columns": [
        "CHUNK",
        "DOCUMENT_TITLE",
        "SOURCE_URL"
      ]
    },
    "WEB_SEARCH": {
      "type": "system_execute_sql",
      "sql_text": "SELECT * FROM TABLE(SNOWGRAM_DB.CORE.WEB_SEARCH(:query));",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "SUGGEST_COMPONENTS_FOR_USE_CASE": {
      "type": "function",
      "identifier": "SNOWGRAM_DB.CORE.SUGGEST_COMPONENTS_JSON",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH",
        "query_timeout": 120
      }
    },
    "GET_ARCHITECTURE_BEST_PRACTICE": {
      "type": "function",
      "identifier": "SNOWGRAM_DB.CORE.GET_ARCHITECTURE_BEST_PRACTICE",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "GENERATE_MERMAID_FROM_COMPONENTS": {
      "type": "function",
      "identifier": "SNOWGRAM_DB.CORE.GENERATE_MERMAID_FROM_COMPONENTS",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "VALIDATE_DIAGRAM_SYNTAX": {
      "type": "function",
      "identifier": "SNOWGRAM_DB.CORE.VALIDATE_MERMAID_SYNTAX",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "query_component_map_sv": {
      "type": "system_execute_sql",
      "sql_text": "SELECT COMPONENT_TYPE, SYNONYM FROM SEMANTIC_VIEW( SNOWGRAM_DB.CORE.COMPONENT_MAP_SV DIMENSIONS SYNONYMS.COMPONENT_TYPE, SYNONYMS.SYNONYM WHERE LOWER(SYNONYMS.SYNONYM) LIKE {{pattern}} ) LIMIT {{limit}};",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "map_component": {
      "type": "system_execute_sql",
      "sql_text": "SELECT SNOWGRAM_DB.CORE.MAP_COMPONENT(:word) AS component_type;",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    },
    "classify_component": {
      "type": "system_execute_sql",
      "sql_text": "SELECT SNOWGRAM_DB.CORE.CLASSIFY_COMPONENT(:component_name) AS classification;",
      "execution_environment": {
        "type": "warehouse",
        "warehouse": "COMPUTE_WH"
      }
    }
  }
}
